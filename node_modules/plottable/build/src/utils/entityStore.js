/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
"use strict";
var Math = require("./mathUtils");
/**
 * Array-backed implementation of {EntityStore}
 */
var EntityArray = (function () {
    function EntityArray() {
        this._entities = [];
    }
    EntityArray.prototype.add = function (entity) {
        this._entities.push(entity);
    };
    /**
     * Iterates through array of of entities and computes the closest point using
     * the standard Euclidean distance formula.
     */
    EntityArray.prototype.entityNearest = function (queryPoint, filter) {
        var closestDistanceSquared = Infinity;
        var closestPointEntity;
        this._entities.forEach(function (entity) {
            if (filter !== undefined && !filter(entity)) {
                return;
            }
            var distanceSquared = Math.distanceSquared(entity.position, queryPoint);
            if (distanceSquared < closestDistanceSquared) {
                closestDistanceSquared = distanceSquared;
                closestPointEntity = entity;
            }
        });
        if (closestPointEntity === undefined) {
            return undefined;
        }
        return closestPointEntity;
    };
    EntityArray.prototype.map = function (callback) {
        return this._entities.map(function (entity) { return callback(entity); });
    };
    EntityArray.prototype.forEach = function (callback) {
        return this._entities.forEach(callback);
    };
    return EntityArray;
}());
exports.EntityArray = EntityArray;
