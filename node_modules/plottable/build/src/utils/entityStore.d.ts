/**
 * Copyright 2014-present Palantir Technologies
 * @license MIT
 */
import { Point } from "../core/interfaces";
/**
 * EntityStore stores entities and makes them searchable.
 * Valid entities must be positioned in Cartesian space.
 */
export interface IEntityStore<T extends IPositionedEntity> {
    /**
     * Adds an entity to the store
     * @param {T} [entity] Entity to add to the store. Entity must be positionable
     */
    add(entity: T): void;
    /**
     * Returns closest entity to a given {Point}
     * @param {Point} [point] Point around which to search for a closest entity
     * @param {(entity: T) => boolean} [filter] optional method that is called while
     * searching for the entity nearest a point. If the filter returns false, the point
     * is considered invalid and is not considered. If the filter returns true, the point
     * is considered valid and will be considered.
     * @returns {T} Will return the nearest entity or undefined if none are found
     */
    entityNearest(point: Point, filter?: (entity: T) => boolean): T;
    /**
     * Iterator that loops through entities and returns a transformed array
     * @param {(value: T) => S} [callback] transformation function that is passed
     * passed an entity {T} and returns an object {S}.
     * @returns {S[]} The aggregate result of each call to the transformation function
     */
    map<S>(callback: (value: T) => S): S[];
    /**
     * Iterator that loops through entities calls the callback on each iteration.
     * @param {(value: T) => void} [callback] transformation function that is passed
     * passed an entity {T}.
     */
    forEach(callback: (value: T) => void): void;
}
export interface IPositionedEntity {
    position: Point;
}
/**
 * Array-backed implementation of {EntityStore}
 */
export declare class EntityArray<T extends IPositionedEntity> implements IEntityStore<T> {
    private _entities;
    constructor();
    add(entity: T): void;
    /**
     * Iterates through array of of entities and computes the closest point using
     * the standard Euclidean distance formula.
     */
    entityNearest(queryPoint: Point, filter?: (entity: T) => boolean): T;
    map<S>(callback: (value: T) => S): S[];
    forEach(callback: (value: T) => void): void;
}
